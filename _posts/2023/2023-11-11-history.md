---
layout: post
title: React Fiber
date: 2023-11-11 00:00:00
description:
categories: history
tag: React, Fiber, React Architecture
---

# `Fiber` **`Architecture`**에 대해서 살짝쿵 이해해 보기

react의 동작 방식 업데이트 방식

동작 방식을 확인하기 전에 내부 큰 구성 요소들을 알아보면

일단 리액트는 몇개의 큰 모듈로 이뤄저 있습니다.

## 리액트 시스템 구성요소

주요 구성요소는 크게 2개로 나눠서 볼수 있습니다.

웹 개발 프로젝트 기준으로 설명해서 글로벌 컨텍스트에서 사용하는 모듈 `리액트`, `리액트 돔` 입니다.

일단 `리액트`는 엘리먼트를 리액트 컴포넌트로 정의하고 리액트엘리먼트 객체로 만들어 주는 역할을 하는 패키지 입니다. 즉, 우리가 정의한 컴포넌트를 리액트 엘리먼트 객체로 만들어 줍니다.

리액트 자체는 호스트 환경에 영향을 받지 않기 때문에 리액트웹, 리액트네이티브등이 호환 되는거라고 볼수있습니다.

리액트 패키지는 다른 패키지에 호환되지 않은 시작점이라고 볼수 있습니다. JSX만이 호환성을 갖고 있다고 말할수도 있겠네요.

`리액트 랜더러` 는 실행 환경에 따라 여러개가 있습니다. `react-dom` `react-native-renderer` 등이 있죠. 우리가 아무리 체이닝되어 잘 추상화 된 리액트 엘리먼트 객체를 가지고 잇어도, 그 객체를 실제 화면에 그리기 위해서는 화면에 연결해야 합니다. 그리고 브라우저등의 호스트 환경에 영향을 받습니다. 어댑터용도의 패키지 이기 때문에 호환성 관련 코드로 구성되어 있고, html element 요소의 속성 정보등이 포함되어 있습니다.

dom은 웹환경에서는 매우 중요한 요소입니다. dom에 사실 직접적인 접근을 하고 위임을 담당하는 패키지 이기 때문에 fluncsync같은 매소드등으로 랜더링 시점을 동기적으로 제어하는 등의 기능이 포함되어 있기도 합니다.

우리가 흔히 사용하는 리액트 돔과 리액트 네이티브 렌더러가 요기에 해당합니다.

리액트는 이벤트 핸들러를 등록하기 위해서 사용되는 패키지가 있습니다.

일단 리액트는 가상돔을 통해서 실제 돔을 업데이트 하는 구조 이기 때문에 실제 돔에 직접 등록된 이벤트 핸들러는 사실 없습니다.

컴포넌트에 JSX로 정의된 요소의 이벤트는 리액트 시멘틱 이벤트라는 것인데,

호스트 네이티브 이벤트를 감싸서 호환성을 맞춰줘 동작의 일관성을 맞춰주기 위해서 사용됩니다. 그렇기 때문에 이벤트 객체에는 일반 네이티브 이벤트 객체에는 없는 속성등이 있습니다. 기량
`nativeEvent` 같은 속성들이죠.

렌더링 되는 시점에 실제로 돔에 이벤트 핸들러가 등록됩니다. 이때 이벤트 핸들러가 등록되는 위치는 실제로 react dom 이 랜더링 되도록 하는 루트 root엘리먼트에 등록됩니다. 동적으로 만들어진 엘리먼트 이외의 최조의 실제 돔 요소는 react dom에 바인딩된 root 요소 밖에 없으니까요.

그리고 이벤트 위임 기법으로 컴포넌트에 정의된 이벤트가 새로 업데이트된 돔 요소에 이벤트가 등록되어 실행되는 동작이 가능해 지는 거죠.

이런 일련의 과정은 `리액트 바인딩`이라는 패키지에서 담당합니다.

**`scheduler`**

리액트는 자체적으로 비동기 처리를 위한 장치로 스케줄러 패키지를 사용합니다.

여러가지 테스크의 순서를 정하고 실행하고 정지하고 다시 실행하는 기능이 포함되어 있습니다.

스케쥴러가 비동기적으로 테스크를 처리하는 것은 자바스크립트 이벤트루프 시스템을 이용합니다.

우선순위 플래그와 테스크의 실행 시간의 정보 딜레이 속성에 의존해서 우선순위를 정하고 타이머를 이용해서 작업 순위를 정합니다. 이벤트루프용도로 사용하는 웹 API도 우선순위에 따라 다른데,

우선순위에 따라 높은 우선순위의 작업은 requestAnimationFrame을 사용하고, 낮은 우선순위의 작업은 requestIdleCallback을 사용합니다.

—

~~settimeout의 지연 이슈(지연시간이 0ms 여도 4ms 이후 실행됩니다.)와 정확성으로 인해서 setImmediate를 사용합니다.~~

**`reconciler`**

가상돔의 변화를 감지하고 업데이트를 결정하는 것이 주요 역할 입니다.

비교 알고리즘으로 가상돔의 변화를 감지합니다. 재조정이라고 알려진 기능이 포함되어 있죠.

16버전을 기점으로 fiber 객체가 reconciler로 체택되어 기존의 스택 구조의 리컨실러는 이제 사용되지 않습니다. 이전 방식을 간단하게 설명하자면

스택리컨실러의 실행순서는 정말 순차적이고 동기적이였습니다. 그래서 아무리 컴포넌트를 작은 단위로 쪼개서 업데이트 과정을 잘내 나눈다고 하더라도 중간에 느려질수 있는 요인이 있는 컴포넌트의 경우는 랜더링 블로커가 될수 있었습니다.

이런 이유로 새로운 피버 리컨실러를 구상할때 리액트 개발팀에서는 랜더링 순위를 매기고 비동기 적으로 처리하도록 했습니다.

그러기 위해서는 일단 피버객체를 새롭게 만들어 사용하게 되었습니다. 피버객체는 리액티엘리먼트 객체와 비슷해 보이지만 몇가지 특징이 있습니다.

우선순위와 관계 정보가 추가되었습니다. 우선순위는 6개의 레벨로 나뉘어서 관리 됩니다. 관계 정보를 통해서 탐색을 진행해서 형재와 부모 자식 관계로 탐색을 진행하는데 일반적으로 DFS 탐색 알고리즘을 사용합니다. 자식 > 형재 > 부모순으로 탐색을 하게 되죠.

또 재사용성을 위해서 트리구조의 노드 구조로 실행 관계를 정의하는데 총 두개로 정의합니다.

현재 핸더링된 정보를 담고있는 커렌트 노드와 그 복사본인 워크인프로그래스 노트 트리인데

우리가 흔히 알고 있는 랜더단계에서는 이 두개의 노드를 비교하고 커밋 페이즈에서는 이 노드를 교체하는 작업을 합니다. 이것을 하나의 워크로 정의하고 이 워크는 앞서 말한 스케줄러가 관장합니다.

랜더단계는 컴포넌트를 호출하는 단계입니다. 살짝만 더 자세히 말하면 컴포넌트는 모두 고유 키 정보를 가지고 있고 피버 객체 또한 이정보를 가지고 있습니다. 컴포넌트 호출과 동시에 기존의 커렌트트리노드를 워크인프로그레스 노드로 복제하고 리액트 재조정알고리즘으로 비교를 합니다. 비교 과정은 effect를 수집하는 활동은데, 키와 props을 감지합니다. effect값은 커밋 단계로 VDOM 객체를 넘깁니다. 대략 이 과정으로 랜더 페이즈는 마무리 됩니다. 렌더 단계는 비동기적이고, 유연한 단계 이기 때문에 이 과정에서 최적화를 진행합니다.

커밋 페이즈에서는 앞서 랜더 페이즈에서 넘겨온 effect 정보를 토대로 피버객체를 통해 Vdom을 새로운 DOM에 업데이트 합니다. 이때 fiber에서 앞서 체크한 effect 정보를 근거로 업데이트 여부를 판단하는데 ,만약 업데이트를 하지 않아도 되는 조건의 요소는 effect flag에서 제외됩니다. 정리된 vdom은 dom에 선별적으로 업데이트 됩니다. 이제 새로운 dom은 vdom의 current 참조 정보로 활용되며, 업데이트를 위한 새로운 vdom이 메모리에 올라가게 됩니다.

사실 리컨실러 패키지는 스케쥴러 패키지와 깊은 연관관계가 있습니다. ~~렌더와 커밋 단계를 하나의 워크 사이클이라고 하고~~, 이 과정을 스케쥴러가 관장하게 되죠.스케쥴러의 스케줄링 제어를 위한 값은 피거 객체를 참조해서 결정하게 되구요.

`fiber`

그렇다면 최종적으로 피버객체의 참조를 통해 어떻게 스케쥴러가 스케쥴링을 하는지 비교를 하기위해서 어떤 값을 사용하는지 알기 위해 피버 객체에 대해서 가볍게 훑어 보겠습니다.

`type, key` -

비교를 위해서 사용되는 값은 식별 값으로써 type과 key, 그리고 상태값으로써 props과 state입니다.

props과 state는 다들 아는 개념이라 넘어가고,

type은 컴포넌트에 정의된 요소입니다. 자세히는 함수에서 JSX로 정의한 컴포넌트 요소죠. 호스트 컴포넌트의 경우 type은 문자열이지만 대부분의 합성 컴포넌트는 함수를 가르킵니다. 이찌 되었든 컴포넌트는 노드 트리구조의 부모자식 관계를 가지고 있기 때문에 해당 컴포넌트의 정의된 요소가 변경되면 비교 알고리즘을 통해 업데이트 대상이 됩니다.

요소가 동일하다면 속성을 비교하게 되며, 부모요소이 변경되면 자식도 자동으로 변경 대상이 됩니다.

이런 점을 개선하기 위해서 memo함수나 key가 사용되죠.

key는 요소의 고유한 식별자로써 불필요한 비교를 해서 워크인프로그레스 노트 트리의 재사용성을 높이기 위해서 사용한다는것을 알고 있습니다. 앞서 불필요하게 새로 업데이트되는 요소를 줄이기 위해서 key를 통해 같은 값을 가지고 있는 요소의 업데이트 대상에서 제외할수 있습니다.

`child, sibling, return` - 재귀적 처리를 위한 포인터들

앞서 설명한 랜더 단계에서 워크인프로세스트리를 갱신하는것은 재귀적으로 처리됩니다. 재귀적 처리를 돕기위해서 자식, 형재, 부모의 관계를 알수있는 포인터가 필요한데 리턴만 좀 워딩이 햇갈릴수 있지만 return은 부모요소의 포인터로 보면됩니다. 결국 최종 도착점은 root가 됩니다.

`nextEffect, firstEffect, **lastEffect**`

nextEffect는 최적화를 업데이트 순서를 파악하기위한 포인터로 보면 됩니다. 랜더페이즈에서 피버 객체에 effect 정보는 커밋페이즈에서 활용되어서 최종적으로 업데이트 선정 정보로 활용되어 집니다.

`햇갈릴수 있는 부분`

우선 요약하면 `Fiber **Architecture**`의 기본적인 핵심은 **`scheduler` 와 `fiber` 객체로 생각하면 됩니다.**

순서만 잘 기억한다면 이제 어려운것은 없다고 생각합니다.

서살 많이 햇갈려 하는 부분은 vDom의 사전적 의미로써의 햇갈림입니다. vDom은 우리가 알고있는 웹의 Dom과는 아무런 관계가 없습니다. 렌더러에 의해서 여러 곳에서 사용되어 집니다. 그렇기 때문에 용어가 바뀌어야 하지 않나라는 생각을 합니다.
